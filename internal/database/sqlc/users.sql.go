// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccountType = `-- name: CreateAccountType :one
INSERT INTO account_types
(name, active)
VALUES($1, $2)
RETURNING id, name, active, inserted_at, updated_at
`

type CreateAccountTypeParams struct {
	Name   string      `json:"name"`
	Active pgtype.Bool `json:"active"`
}

func (q *Queries) CreateAccountType(ctx context.Context, arg CreateAccountTypeParams) (AccountType, error) {
	row := q.db.QueryRow(ctx, createAccountType, arg.Name, arg.Active)
	var i AccountType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccountType = `-- name: DeleteAccountType :one
DELETE FROM account_types
WHERE id = $1 OR name = $1
RETURNING id, name, active, inserted_at, updated_at
`

func (q *Queries) DeleteAccountType(ctx context.Context, id pgtype.UUID) (AccountType, error) {
	row := q.db.QueryRow(ctx, deleteAccountType, id)
	var i AccountType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountTypeById = `-- name: GetAccountTypeById :one
SELECT id, name, active, inserted_at, updated_at FROM account_types
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAccountTypeById(ctx context.Context, id pgtype.UUID) (AccountType, error) {
	row := q.db.QueryRow(ctx, getAccountTypeById, id)
	var i AccountType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountTypeByName = `-- name: GetAccountTypeByName :one
SELECT id, name, active, inserted_at, updated_at FROM account_types
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetAccountTypeByName(ctx context.Context, name string) (AccountType, error) {
	row := q.db.QueryRow(ctx, getAccountTypeByName, name)
	var i AccountType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAccountTypes = `-- name: ListAccountTypes :many
SELECT id, name, active, inserted_at, updated_at FROM account_types
ORDER BY inserted_at DESC
`

func (q *Queries) ListAccountTypes(ctx context.Context) ([]AccountType, error) {
	rows, err := q.db.Query(ctx, listAccountTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountType{}
	for rows.Next() {
		var i AccountType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.InsertedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountTypeByID = `-- name: UpdateAccountTypeByID :one
UPDATE account_types
SET name=$2, active=$2
WHERE id = $1
RETURNING id, name, active, inserted_at, updated_at
`

type UpdateAccountTypeByIDParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) UpdateAccountTypeByID(ctx context.Context, arg UpdateAccountTypeByIDParams) (AccountType, error) {
	row := q.db.QueryRow(ctx, updateAccountTypeByID, arg.ID, arg.Name)
	var i AccountType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return i, err
}
